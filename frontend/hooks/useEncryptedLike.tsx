"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These files will be generated by genabi.mjs script
import { EncryptedLikeAddresses } from "@/abi/EncryptedLikeAddresses";
import { EncryptedLikeABI } from "@/abi/EncryptedLikeABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type EncryptedLikeInfoType = {
  abi: typeof EncryptedLikeABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

// Reaction types enum (matching contract)
export enum ReactionType {
  Like = 0,      // üëç ÁÇπËµû
  Love = 1,      // ‚ù§Ô∏è Áà±ÂøÉ
  Clap = 2,      // üëè ÈºìÊéå
  Celebrate = 3, // üéâ Â∫ÜÁ•ù
  Idea = 4       // üí° ÊÉ≥Ê≥ï
}

export const ReactionEmojis = {
  [ReactionType.Like]: "üëç",
  [ReactionType.Love]: "‚ù§Ô∏è",
  [ReactionType.Clap]: "üëè",
  [ReactionType.Celebrate]: "üéâ",
  [ReactionType.Idea]: "üí°",
};

export const ReactionNames = {
  [ReactionType.Like]: "Like",
  [ReactionType.Love]: "Love",
  [ReactionType.Clap]: "Clap",
  [ReactionType.Celebrate]: "Celebrate",
  [ReactionType.Idea]: "Idea",
};

export type PostType = {
  id: number;
  author: string;
  content: string;
  category: string;
  tags: string[];
  timestamp: bigint;
  reactionHandles: {
    [ReactionType.Like]?: string;
    [ReactionType.Love]?: string;
    [ReactionType.Clap]?: string;
    [ReactionType.Celebrate]?: string;
    [ReactionType.Idea]?: string;
  };
  decryptedReactions: {
    [ReactionType.Like]?: bigint;
    [ReactionType.Love]?: bigint;
    [ReactionType.Clap]?: bigint;
    [ReactionType.Celebrate]?: bigint;
    [ReactionType.Idea]?: bigint;
  };
  commentCountHandle?: string;
  decryptedCommentCount?: bigint;
  userReaction?: ReactionType;
  isAuthor: boolean;
};

export type CommentType = {
  id: number;
  author: string;
  postId: number;
  parentCommentId: number;
  timestamp: bigint;
  likeCountHandle?: string;
  decryptedLikeCount?: bigint;
  contentHandles?: string[];
  decryptedContent?: string;
  isAuthor: boolean;
  canDecrypt?: boolean; // true if current user is post author or comment author
};

function getEncryptedLikeByChainId(
  chainId: number | undefined
): EncryptedLikeInfoType {
  if (!chainId) {
    return { abi: EncryptedLikeABI.abi };
  }

  const entry =
    EncryptedLikeAddresses[chainId.toString() as keyof typeof EncryptedLikeAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: EncryptedLikeABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: EncryptedLikeABI.abi,
  };
}

export const useEncryptedLike = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
  userAddress: string | undefined;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
    userAddress,
  } = parameters;

  const [posts, setPosts] = useState<PostType[]>([]);
  const [comments, setComments] = useState<CommentType[]>([]);
  const [postCount, setPostCount] = useState<number>(0);
  const [message, setMessage] = useState<string>("");
  const [isCreatingPost, setIsCreatingPost] = useState<boolean>(false);
  const [isReacting, setIsReacting] = useState<boolean>(false);
  const [isAddingComment, setIsAddingComment] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);

  const encryptedLikeRef = useRef<EncryptedLikeInfoType | undefined>(undefined);
  const isCreatingPostRef = useRef<boolean>(false);
  const isReactingRef = useRef<boolean>(false);
  const isAddingCommentRef = useRef<boolean>(false);
  const isDecryptingRef = useRef<boolean>(false);
  const isRefreshingRef = useRef<boolean>(false);

  const encryptedLike = useMemo(() => {
    const c = getEncryptedLikeByChainId(chainId);
    encryptedLikeRef.current = c;
    // Only show error message when chainId is defined (known) and address is missing
    // Don't show error if chainId is undefined (not connected) or address exists
    if (chainId !== undefined && !c.address) {
      setMessage(`EncryptedLike deployment not found for chainId=${chainId}.`);
    } else if (chainId === undefined || c.address) {
      // Clear deployment error message if chainId is undefined or address exists
      // Use a callback to check if current message is the deployment error
      setMessage((prev) => {
        if (prev.startsWith("EncryptedLike deployment not found")) {
          return "";
        }
        return prev;
      });
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!encryptedLike) {
      return undefined;
    }
    return (
      Boolean(encryptedLike.address) &&
      encryptedLike.address !== ethers.ZeroAddress
    );
  }, [encryptedLike]);

  const refreshPosts = useCallback(() => {
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !encryptedLikeRef.current?.address ||
      !encryptedLikeRef.current?.chainId ||
      !ethersReadonlyProvider
    ) {
      setPosts([]);
      setPostCount(0);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = encryptedLikeRef.current.chainId;
    const thisContractAddress = encryptedLikeRef.current.address;

    const contract = new ethers.Contract(
      thisContractAddress,
      encryptedLikeRef.current.abi,
      ethersReadonlyProvider
    );

    // Get function references to resolve overload ambiguity
    const getCommentCountNoParam = contract.getFunction("getCommentCount()");

    Promise.all([
      contract.getPostCount(),
      contract.getPostCount().then(async (count: bigint) => {
        const postPromises: Promise<PostType>[] = [];
        for (let i = 0; i < Number(count); i++) {
          postPromises.push(
            contract.getPost(i).then(async (postData: any) => {
              // Get all reaction count handles
              const reactionHandles: any = {};
              for (let rt = 0; rt < 5; rt++) {
                try {
                  reactionHandles[rt] = await contract.getReactionCount(i, rt);
                } catch (e) {
                  // Ignore if reaction count not available
                }
              }
              
              // Use explicit function signature to avoid ambiguity with getCommentCount() overload
              const getCommentCountWithParam = contract.getFunction("getCommentCount(uint256)");
              const commentCountHandle = await getCommentCountWithParam(i);
              
              // Get user's reaction
              let userReaction: ReactionType | undefined;
              if (userAddress) {
                try {
                  const userReactionValue = await contract.getUserReaction(userAddress, i);
                  userReaction = Number(userReactionValue) as ReactionType;
                } catch (e) {
                  // Ignore if user reaction not available
                }
              }
              
              return {
                id: i,
                author: postData.author,
                content: postData.content,
                category: postData.category || "",
                tags: postData.tags || [],
                timestamp: postData.timestamp,
                reactionHandles: reactionHandles,
                decryptedReactions: {},
                commentCountHandle: commentCountHandle,
                userReaction: userReaction,
                isAuthor: userAddress?.toLowerCase() === postData.author.toLowerCase(),
              } as PostType;
            })
          );
        }
        return Promise.all(postPromises);
      }),
      // Fetch comments - use explicit function signature to avoid ambiguity with getCommentCount(uint256) overload
      getCommentCountNoParam().then(async (commentCount: bigint) => {
        // Get posts first to check authorship
        const postsData = await contract.getPostCount().then(async (count: bigint) => {
          const postPromises: Promise<{ id: number; author: string }>[] = [];
          for (let i = 0; i < Number(count); i++) {
            postPromises.push(
              contract.getPost(i).then((postData: any) => ({
                id: i,
                author: postData.author,
              }))
            );
          }
          return Promise.all(postPromises);
        });

        const commentPromises: Promise<CommentType>[] = [];
        for (let i = 0; i < Number(commentCount); i++) {
          commentPromises.push(
            contract.getComment(i).then(async (commentData: any) => {
              // Fetch encrypted content chunk handles
              let contentHandles: string[] = [];
              try {
                const chunkCount: bigint = await contract.getCommentContentChunkCount(i);
                const chunkPromises: Promise<string>[] = [];
                for (let idx = 0; idx < Number(chunkCount); idx++) {
                  chunkPromises.push(contract.getCommentContentChunk(i, idx));
                }
                contentHandles = await Promise.all(chunkPromises);
              } catch (e) {
                // Ignore if content not available
              }

              // Check if current user can decrypt (post author or comment author)
              const isCommentAuthor = userAddress?.toLowerCase() === commentData.author.toLowerCase();
              // Check if user is post author
              const post = postsData.find(p => p.id === Number(commentData.postId));
              const isPostAuthor = post && userAddress?.toLowerCase() === post.author.toLowerCase();
              const canDecrypt = isCommentAuthor || isPostAuthor || false;

              return {
                id: i,
                author: commentData.author,
                postId: Number(commentData.postId),
                parentCommentId: Number(commentData.parentCommentId),
                timestamp: commentData.timestamp,
                contentHandles: contentHandles,
                isAuthor: isCommentAuthor,
                canDecrypt: canDecrypt,
              } as CommentType;
            })
          );
        }
        return Promise.all(commentPromises);
      }),
    ])
      .then(([count, postsData, commentsData]) => {
        if (
          sameChain.current(thisChainId) &&
          thisContractAddress === encryptedLikeRef.current?.address
        ) {
          setPostCount(Number(count));
          // Sort posts by timestamp descending (newest first)
          const sortedPosts = [...postsData].sort((a, b) => {
            const timestampA = Number(a.timestamp);
            const timestampB = Number(b.timestamp);
            return timestampB - timestampA; // Descending order
          });
          setPosts(sortedPosts);
          // Sort comments by timestamp descending (newest first)
          const sortedComments = (commentsData || []).sort((a, b) => {
            const timestampA = Number(a.timestamp);
            const timestampB = Number(b.timestamp);
            return timestampB - timestampA; // Descending order
          });
          setComments(sortedComments);
        }
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("Failed to fetch posts: " + e);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, sameChain, userAddress]);

  useEffect(() => {
    refreshPosts();
  }, [refreshPosts]);

  const createPost = useCallback(
    async (content: string, category: string = "", tags: string[] = []) => {
      if (isCreatingPostRef.current || isRefreshingRef.current) {
        return;
      }

      if (!encryptedLike.address || !instance || !ethersSigner || !content.trim()) {
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = encryptedLike.address;
      const thisEthersSigner = ethersSigner;

      isCreatingPostRef.current = true;
      setIsCreatingPost(true);
      setMessage("Creating post...");

      const run = async () => {
        const isStale = () =>
          thisContractAddress !== encryptedLikeRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const contract = new ethers.Contract(
            thisContractAddress,
            encryptedLike.abi,
            thisEthersSigner
          );

          const tx = await contract.createPost(content, category || "", tags || []);
          setMessage(`Waiting for tx: ${tx.hash}...`);

          const receipt = await tx.wait();
          setMessage(`Post created! Status: ${receipt?.status}`);

          if (isStale()) {
            setMessage("Ignore post creation");
            return;
          }

          refreshPosts();
        } catch (error: any) {
          setMessage(`Create post failed: ${error.message}`);
        } finally {
          isCreatingPostRef.current = false;
          setIsCreatingPost(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      encryptedLike.address,
      encryptedLike.abi,
      instance,
      chainId,
      refreshPosts,
      sameChain,
      sameSigner,
    ]
  );


  const addReaction = useCallback(
    async (postId: number, reactionType: ReactionType) => {
      if (isRefreshingRef.current || isReactingRef.current) {
        return;
      }

      if (!encryptedLike.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = encryptedLike.address;
      const thisEthersSigner = ethersSigner;

      isReactingRef.current = true;
      setIsReacting(true);
      setMessage(`Adding ${ReactionNames[reactionType]} to post ${postId}...`);

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisContractAddress !== encryptedLikeRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisContractAddress,
            thisEthersSigner.address
          );
          input.add32(1);

          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Ignore reaction");
            return;
          }

          setMessage(`Calling addReaction...`);

          const contract = new ethers.Contract(
            thisContractAddress,
            encryptedLike.abi,
            thisEthersSigner
          );

          const tx = await contract.addReaction(
            postId,
            reactionType,
            enc.handles[0],
            enc.inputProof
          );

          setMessage(`Waiting for tx: ${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`${ReactionNames[reactionType]} added! Status: ${receipt?.status}`);

          if (isStale()) {
            setMessage("Ignore reaction");
            return;
          }

          refreshPosts();
        } catch (error: any) {
          setMessage(`Add reaction failed: ${error.message}`);
        } finally {
          isReactingRef.current = false;
          setIsReacting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      encryptedLike.address,
      encryptedLike.abi,
      instance,
      chainId,
      refreshPosts,
      sameChain,
      sameSigner,
    ]
  );

  const removeReaction = useCallback(
    async (postId: number) => {
      if (isRefreshingRef.current || isReactingRef.current) {
        return;
      }

      if (!encryptedLike.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = encryptedLike.address;
      const thisEthersSigner = ethersSigner;

      isReactingRef.current = true;
      setIsReacting(true);
      setMessage(`Removing reaction from post ${postId}...`);

      const run = async () => {
        const isStale = () =>
          thisContractAddress !== encryptedLikeRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisContractAddress,
            thisEthersSigner.address
          );
          input.add32(1);

          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Ignore remove reaction");
            return;
          }

          const contract = new ethers.Contract(
            thisContractAddress,
            encryptedLike.abi,
            thisEthersSigner
          );

          const tx = await contract.removeReaction(
            postId,
            enc.handles[0],
            enc.inputProof
          );

          setMessage(`Waiting for tx: ${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Reaction removed! Status: ${receipt?.status}`);

          if (isStale()) {
            setMessage("Ignore remove reaction");
            return;
          }

          refreshPosts();
        } catch (error: any) {
          setMessage(`Remove reaction failed: ${error.message}`);
        } finally {
          isReactingRef.current = false;
          setIsReacting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      encryptedLike.address,
      encryptedLike.abi,
      instance,
      chainId,
      refreshPosts,
      sameChain,
      sameSigner,
    ]
  );

  const addComment = useCallback(
    async (postId: number, commentText: string, parentCommentId: number = 0) => {
      if (isRefreshingRef.current || isAddingCommentRef.current) {
        return;
      }

      if (!encryptedLike.address || !instance || !ethersSigner || !commentText.trim()) {
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = encryptedLike.address;
      const thisEthersSigner = ethersSigner;

      isAddingCommentRef.current = true;
      setIsAddingComment(true);
      setMessage(`Adding comment to post ${postId}...`);

      const run = async () => {
        const isStale = () =>
          thisContractAddress !== encryptedLikeRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Encrypt comment content using multi-chunk encoding
          // Pack up to 6 ASCII chars per 32-bit chunk (7 bits per char)
          const contentInput = instance.createEncryptedInput(
            thisContractAddress,
            thisEthersSigner.address
          );
          const chunkSize = 4; // 4 * 7 = 28 bits fits into 32-bit
          for (let offset = 0; offset < commentText.length; offset += chunkSize) {
            let encodedValue = 0;
            const end = Math.min(offset + chunkSize, commentText.length);
            for (let i = offset; i < end; i++) {
              const charCode = commentText.charCodeAt(i) || 32;
              encodedValue = encodedValue * 128 + (charCode % 128);
            }
            contentInput.add32(encodedValue);
          }
          
          const contentEnc = await contentInput.encrypt();

          // Encrypt count increment
          const countInput = instance.createEncryptedInput(
            thisContractAddress,
            thisEthersSigner.address
          );
          countInput.add32(1);
          const countEnc = await countInput.encrypt();

          if (isStale()) {
            setMessage("Ignore comment");
            return;
          }

          const contract = new ethers.Contract(
            thisContractAddress,
            encryptedLike.abi,
            thisEthersSigner
          );

          const tx = await contract.addComment(
            postId,
            parentCommentId,
            contentEnc.handles,
            contentEnc.inputProof,
            countEnc.handles[0],
            countEnc.inputProof
          );

          setMessage(`Waiting for tx: ${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Comment added! Status: ${receipt?.status}`);

          if (isStale()) {
            setMessage("Ignore comment");
            return;
          }

          refreshPosts();
        } catch (error: any) {
          setMessage(`Add comment failed: ${error.message}`);
        } finally {
          isAddingCommentRef.current = false;
          setIsAddingComment(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      encryptedLike.address,
      encryptedLike.abi,
      instance,
      chainId,
      refreshPosts,
      sameChain,
      sameSigner,
    ]
  );

  // Deprecated local implementation (kept for reference, not exported)
  const decryptLikeCountLegacyInternal = useCallback(
    async (postId: number, likeCountHandle: string) => {
      if (isRefreshingRef.current || isDecryptingRef.current) {
        return;
      }

      if (!encryptedLike.address || !instance || !ethersSigner) {
        return;
      }

      if (likeCountHandle === ethers.ZeroHash) {
        setPosts((prev) =>
          prev.map((p) =>
            p.id === postId ? { ...p, decryptedLikeCount: BigInt(0) } : p
          )
        );
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = encryptedLike.address;
      const thisLikeCountHandle = likeCountHandle;
      const thisEthersSigner = ethersSigner;

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage(`Decrypting like count for post ${postId}...`);

      const run = async () => {
        const isStale = () =>
          thisContractAddress !== encryptedLikeRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const sig = await FhevmDecryptionSignature.loadOrSign(
            instance,
            [encryptedLike.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

          if (!sig) {
            setMessage("Unable to build FHEVM decryption signature");
            return;
          }

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          setMessage("Calling FHEVM userDecrypt...");

          const res = await instance.userDecrypt(
            [
              {
                handle: thisLikeCountHandle,
                contractAddress: thisContractAddress,
              },
            ],
            sig.privateKey,
            sig.publicKey,
            sig.signature,
            sig.contractAddresses,
            sig.userAddress,
            sig.startTimestamp,
            sig.durationDays
          );

          setMessage("FHEVM userDecrypt completed!");

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          setPosts((prev) =>
            prev.map((p) =>
              p.id === postId
                ? { ...p, decryptedLikeCount: res[thisLikeCountHandle] as bigint }
                : p
            )
          );

          setMessage(
            `Post ${postId} has ${res[thisLikeCountHandle]} likes`
          );
        } catch (error: any) {
          console.error("Decryption failed:", error);
          setMessage(`Decryption failed: ${error.message}`);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      run();
    },
    [
      fhevmDecryptionSignatureStorage,
      ethersSigner,
      encryptedLike.address,
      instance,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  // Legacy function for backward compatibility
  const addLike = useCallback(
    async (postId: number) => {
      return addReaction(postId, ReactionType.Like);
    },
    [addReaction]
  );

  const decryptReactionCount = useCallback(
    async (postId: number, reactionType: ReactionType, reactionHandle: string) => {
      if (isRefreshingRef.current || isDecryptingRef.current) {
        return;
      }

      if (!encryptedLike.address || !instance || !ethersSigner) {
        return;
      }

      if (reactionHandle === ethers.ZeroHash) {
        setPosts((prev) =>
          prev.map((p) =>
            p.id === postId
              ? {
                  ...p,
                  decryptedReactions: {
                    ...p.decryptedReactions,
                    [reactionType]: BigInt(0),
                  },
                }
              : p
          )
        );
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = encryptedLike.address;
      const thisReactionHandle = reactionHandle;
      const thisEthersSigner = ethersSigner;

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage(`Decrypting ${ReactionNames[reactionType]} count for post ${postId}...`);

      const run = async () => {
        const isStale = () =>
          thisContractAddress !== encryptedLikeRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const sig = await FhevmDecryptionSignature.loadOrSign(
            instance,
            [encryptedLike.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

          if (!sig) {
            setMessage("Unable to build FHEVM decryption signature");
            return;
          }

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          setMessage("Calling FHEVM userDecrypt...");

          const res = await instance.userDecrypt(
            [
              {
                handle: thisReactionHandle,
                contractAddress: thisContractAddress,
              },
            ],
            sig.privateKey,
            sig.publicKey,
            sig.signature,
            sig.contractAddresses,
            sig.userAddress,
            sig.startTimestamp,
            sig.durationDays
          );

          setMessage("FHEVM userDecrypt completed!");

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          setPosts((prev) =>
            prev.map((p) =>
              p.id === postId
                ? {
                    ...p,
                    decryptedReactions: {
                      ...p.decryptedReactions,
                      [reactionType]: res[thisReactionHandle] as bigint,
                    },
                  }
                : p
            )
          );

          setMessage(
            `Post ${postId} has ${res[thisReactionHandle]} ${ReactionNames[reactionType]}`
          );
        } catch (error: any) {
          console.error("Decryption failed:", error);
          setMessage(`Decryption failed: ${error.message}`);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      run();
    },
    [
      fhevmDecryptionSignatureStorage,
      ethersSigner,
      encryptedLike.address,
      instance,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  // Legacy function for backward compatibility
  const decryptLikeCount = useCallback(
    async (postId: number, likeCountHandle: string) => {
      return decryptReactionCount(postId, ReactionType.Like, likeCountHandle);
    },
    [decryptReactionCount]
  );

  const decryptCommentCount = useCallback(
    async (postId: number, commentCountHandle: string) => {
      if (isRefreshingRef.current || isDecryptingRef.current) {
        return;
      }

      if (!encryptedLike.address || !instance || !ethersSigner) {
        return;
      }

      if (commentCountHandle === ethers.ZeroHash) {
        setPosts((prev) =>
          prev.map((p) =>
            p.id === postId
              ? { ...p, decryptedCommentCount: BigInt(0) }
              : p
          )
        );
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = encryptedLike.address;
      const thisCommentCountHandle = commentCountHandle;
      const thisEthersSigner = ethersSigner;

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage(`Decrypting comment count for post ${postId}...`);

      const run = async () => {
        const isStale = () =>
          thisContractAddress !== encryptedLikeRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const sig = await FhevmDecryptionSignature.loadOrSign(
            instance,
            [encryptedLike.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

          if (!sig) {
            setMessage("Unable to build FHEVM decryption signature");
            return;
          }

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          setMessage("Calling FHEVM userDecrypt...");

          const res = await instance.userDecrypt(
            [
              {
                handle: thisCommentCountHandle,
                contractAddress: thisContractAddress,
              },
            ],
            sig.privateKey,
            sig.publicKey,
            sig.signature,
            sig.contractAddresses,
            sig.userAddress,
            sig.startTimestamp,
            sig.durationDays
          );

          setMessage("FHEVM userDecrypt completed!");

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          setPosts((prev) =>
            prev.map((p) =>
              p.id === postId
                ? { ...p, decryptedCommentCount: res[thisCommentCountHandle] as bigint }
                : p
            )
          );

          setMessage(
            `Post ${postId} has ${res[thisCommentCountHandle]} comments`
          );
        } catch (error: any) {
          console.error("Decryption failed:", error);
          setMessage(`Decryption failed: ${error.message}`);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      run();
    },
    [
      fhevmDecryptionSignatureStorage,
      ethersSigner,
      encryptedLike.address,
      instance,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  const decryptCommentContent = useCallback(
    async (commentId: number, contentHandles: string[]) => {
      if (isRefreshingRef.current || isDecryptingRef.current) {
        return;
      }

      if (!encryptedLike.address || !instance || !ethersSigner) {
        return;
      }

      if (!contentHandles || contentHandles.length === 0) {
        setComments((prev) =>
          prev.map((c) =>
            c.id === commentId
              ? { ...c, decryptedContent: "" }
              : c
          )
        );
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = encryptedLike.address;
      const thisContentHandles = contentHandles;
      const thisEthersSigner = ethersSigner;

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage(`Decrypting comment ${commentId} content...`);

      const run = async () => {
        const isStale = () =>
          thisContractAddress !== encryptedLikeRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const sig = await FhevmDecryptionSignature.loadOrSign(
            instance,
            [encryptedLike.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

          if (!sig) {
            setMessage("Unable to build FHEVM decryption signature");
            return;
          }

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          setMessage("Calling FHEVM userDecrypt...");

          const res = await instance.userDecrypt(
            thisContentHandles.map((h) => ({ handle: h, contractAddress: thisContractAddress })),
            sig.privateKey,
            sig.publicKey,
            sig.signature,
            sig.contractAddresses,
            sig.userAddress,
            sig.startTimestamp,
            sig.durationDays
          );

          setMessage("FHEVM userDecrypt completed!");

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          // Convert decrypted chunks back to string
          const decodeChunk = (val: number): string => {
            let tmp = val;
            const chunkChars: string[] = [];
            while (tmp > 0) {
              const code = tmp % 128;
              if (code >= 32 && code <= 126) {
                chunkChars.unshift(String.fromCharCode(code));
              }
              tmp = Math.floor(tmp / 128);
            }
            return chunkChars.join("");
          };
          const decryptedText = thisContentHandles
            .map((h) => Number(res[h] as bigint))
            .map(decodeChunk)
            .join("");

          setComments((prev) =>
            prev.map((c) =>
              c.id === commentId
                ? { ...c, decryptedContent: decryptedText }
                : c
            )
          );

          setMessage(`Comment ${commentId} decrypted successfully`);
        } catch (error: any) {
          console.error("Decryption failed:", error);
          setMessage(`Decryption failed: ${error.message}`);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      run();
    },
    [
      fhevmDecryptionSignatureStorage,
      ethersSigner,
      encryptedLike.address,
      instance,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  const getReactionStatus = (reactionCount: bigint | undefined): string => {
    if (reactionCount === undefined) {
      return "‚ú® Normal";
    }
    const count = Number(reactionCount);
    if (count >= 10) {
      return "üî• Hot";
    } else if (count >= 5) {
      return "üí¨ Active";
    } else {
      return "‚ú® Normal";
    }
  };

  // Legacy function for backward compatibility
  const getLikeStatus = getReactionStatus;

  return {
    contractAddress: encryptedLike.address,
    isDeployed,
    posts,
    comments,
    postCount,
    message,
    isCreatingPost,
    isReacting,
    isAddingComment,
    isDecrypting,
    isRefreshing,
    createPost,
    addLike,
    addReaction,
    removeReaction,
    addComment,
    decryptLikeCount,
    decryptReactionCount,
    decryptCommentCount,
    decryptCommentContent,
    refreshPosts,
    getLikeStatus,
    getReactionStatus,
    ReactionType,
    ReactionEmojis,
    ReactionNames,
  };
};

